[{"filePath":"C:\\Users\\admin\\Documents\\Web Projects\\chooz-app\\eslint.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\admin\\Documents\\Web Projects\\chooz-app\\src\\App.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\admin\\Documents\\Web Projects\\chooz-app\\src\\components\\Coin\\CoinGame.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\admin\\Documents\\Web Projects\\chooz-app\\src\\components\\Coin\\CoinGame.styles.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\admin\\Documents\\Web Projects\\chooz-app\\src\\components\\Dice\\DiceGame.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\admin\\Documents\\Web Projects\\chooz-app\\src\\components\\Dice\\DiceGame.styles.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\admin\\Documents\\Web Projects\\chooz-app\\src\\components\\Dice\\DiceUtils.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\admin\\Documents\\Web Projects\\chooz-app\\src\\components\\Home\\HomePage.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\admin\\Documents\\Web Projects\\chooz-app\\src\\components\\LandingPage.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\admin\\Documents\\Web Projects\\chooz-app\\src\\components\\MarbleRace\\MarbleCanvas.jsx","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'dpr' is assigned a value but never used. Allowed unused vars must match /^[A-Z_]/u.","line":87,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":87,"endColumn":14,"suggestions":[{"messageId":"removeVar","data":{"varName":"dpr"},"fix":{"range":[2714,2755],"text":""},"desc":"Remove unused variable 'dpr'."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useRef, useEffect, useState, memo } from 'react';\r\nimport { COURSE, CAMERA, COLORS, OBSTACLES } from './MarbleConstants';\r\nimport { createBalls, updateBalls } from './MarblePhysics';\r\nimport { generateCourse } from './MarbleObstacles';\r\nimport {\r\n  drawBall,\r\n  drawObstacle,\r\n  drawFinishLine,\r\n  drawWalls,\r\n  drawBackground,\r\n  drawLeaderboard,\r\n  drawProgressBar,\r\n  drawParticle\r\n} from './MarbleDrawing';\r\nimport { playTick, playWin } from '../../utils/sounds';\r\n\r\n/**\r\n * Canvas component for the Marble Race.\r\n * Handles physics simulation, rendering, and camera following.\r\n */\r\nconst MarbleCanvas = ({ names, racing, onRaceFinish, mode }) => {\r\n  const containerRef = useRef(null);\r\n  const canvasRef = useRef(null);\r\n  const animFrameRef = useRef(null);\r\n  const ballsRef = useRef([]);\r\n  const obstaclesRef = useRef([]);\r\n  const particlesRef = useRef([]);\r\n  const cameraYRef = useRef(0);\r\n  const racingRef = useRef(false);\r\n  const modeRef = useRef(mode);\r\n  const finishYRef = useRef(0);\r\n  const firstFinisherRef = useRef(null);\r\n  const allFinishedRef = useRef(false);\r\n  const [size, setSize] = useState({ width: 0, height: 0 });\r\n\r\n  useEffect(() => { modeRef.current = mode; }, [mode]);\r\n\r\n  // Resize observer\r\n  useEffect(() => {\r\n    if (!containerRef.current) return;\r\n    const observer = new ResizeObserver((entries) => {\r\n      for (const entry of entries) {\r\n        const { width, height } = entry.contentRect;\r\n        setSize({ width, height });\r\n      }\r\n    });\r\n    observer.observe(containerRef.current);\r\n    return () => observer.disconnect();\r\n  }, []);\r\n\r\n  // Initialize canvas\r\n  useEffect(() => {\r\n    if (size.width === 0 || size.height === 0) return;\r\n    const canvas = canvasRef.current;\r\n    const dpr = window.devicePixelRatio || 1;\r\n    canvas.width = size.width * dpr;\r\n    canvas.height = size.height * dpr;\r\n  }, [size]);\r\n\r\n  // Start race\r\n  useEffect(() => {\r\n    if (racing && !racingRef.current) {\r\n      racingRef.current = true;\r\n      firstFinisherRef.current = null;\r\n      allFinishedRef.current = false;\r\n      cameraYRef.current = 0;\r\n\r\n      const courseWidth = COURSE.WIDTH;\r\n      const courseHeight = COURSE.HEIGHT;\r\n      finishYRef.current = courseHeight - COURSE.FINISH_LINE_HEIGHT;\r\n      obstaclesRef.current = generateCourse(courseWidth, courseHeight);\r\n      ballsRef.current = createBalls(names, courseWidth);\r\n      particlesRef.current = [];\r\n    }\r\n\r\n    if (!racing) {\r\n      racingRef.current = false;\r\n    }\r\n  }, [racing, names]);\r\n\r\n  // Main render loop\r\n  useEffect(() => {\r\n    if (size.width === 0 || size.height === 0) return;\r\n\r\n    const canvas = canvasRef.current;\r\n    const ctx = canvas.getContext('2d');\r\n    const dpr = window.devicePixelRatio || 1;\r\n    const courseWidth = COURSE.WIDTH;\r\n    const viewportHeight = CAMERA.VIEWPORT_HEIGHT;\r\n    const scaleX = canvas.width / courseWidth;\r\n    const scaleY = canvas.height / viewportHeight;\r\n    const scale = Math.min(scaleX, scaleY);\r\n\r\n    let lastTickTime = 0;\r\n\r\n    const render = (timestamp) => {\r\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n      ctx.save();\r\n      // Center the course\r\n      const offsetX = (canvas.width - courseWidth * scale) / 2;\r\n      ctx.translate(offsetX, 0);\r\n      ctx.scale(scale, scale);\r\n\r\n      const cameraY = cameraYRef.current;\r\n\r\n      // Background\r\n      drawBackground(ctx, courseWidth, viewportHeight);\r\n\r\n      // Walls\r\n      drawWalls(ctx, courseWidth, cameraY, viewportHeight);\r\n\r\n      // Obstacles\r\n      for (const obs of obstaclesRef.current) {\r\n        drawObstacle(ctx, obs, cameraY, viewportHeight);\r\n      }\r\n\r\n      // Finish line\r\n      drawFinishLine(ctx, finishYRef.current, cameraY, courseWidth, viewportHeight);\r\n\r\n      // Balls\r\n      const balls = ballsRef.current;\r\n      let leaderIndex = -1;\r\n      let leaderY = -Infinity;\r\n      for (let i = 0; i < balls.length; i++) {\r\n        if (!balls[i].finished && balls[i].y > leaderY) {\r\n          leaderY = balls[i].y;\r\n          leaderIndex = i;\r\n        }\r\n      }\r\n\r\n      // Sort by y so closer balls draw on top\r\n      const sortedBalls = [...balls].sort((a, b) => a.y - b.y);\r\n\r\n      // Physics step\r\n      if (racingRef.current) {\r\n        const { collisions, newFinishers } = updateBalls(\r\n          balls,\r\n          obstaclesRef.current,\r\n          courseWidth,\r\n          finishYRef.current,\r\n          timestamp,\r\n          particlesRef.current\r\n        );\r\n\r\n        // Update and draw particles behind balls\r\n        const particles = particlesRef.current;\r\n        for (let i = particles.length - 1; i >= 0; i--) {\r\n          const p = particles[i];\r\n          p.x += p.vx;\r\n          p.y += p.vy;\r\n          p.vy += 0.2; // gravity\r\n          p.life -= 1 / p.maxLife;\r\n          if (p.life <= 0) {\r\n            particles.splice(i, 1);\r\n          } else {\r\n            drawParticle(ctx, p, cameraY, viewportHeight);\r\n          }\r\n        }\r\n\r\n        // Draw Balls\r\n        for (const ball of sortedBalls) {\r\n          drawBall(ctx, ball, cameraY, viewportHeight, ball.id === leaderIndex, size.width);\r\n        }\r\n\r\n        // Tick sound on collisions (throttled)\r\n        if (collisions > 0 && timestamp - lastTickTime > 50) {\r\n          playTick(0.8 + Math.random() * 0.4);\r\n          lastTickTime = timestamp;\r\n        }\r\n\r\n        // Handle finishers\r\n        if (newFinishers.length > 0) {\r\n          if (!firstFinisherRef.current) {\r\n            firstFinisherRef.current = newFinishers[0];\r\n            playWin();\r\n\r\n            if (modeRef.current === 'first') {\r\n              racingRef.current = false;\r\n              onRaceFinish([firstFinisherRef.current]);\r\n            }\r\n          }\r\n        }\r\n\r\n        // Check if all finished (ranked mode)\r\n        if (modeRef.current === 'ranked' && racingRef.current) {\r\n          const allDone = balls.every(b => b.finished);\r\n          if (allDone && !allFinishedRef.current) {\r\n            allFinishedRef.current = true;\r\n            racingRef.current = false;\r\n            const ranked = [...balls].sort((a, b) => a.finishOrder - b.finishOrder);\r\n            onRaceFinish(ranked);\r\n          }\r\n        }\r\n\r\n        // Camera follow leader\r\n        if (leaderIndex >= 0) {\r\n          const targetY = balls[leaderIndex].y - viewportHeight * 0.4;\r\n          const clampedTarget = Math.max(0, Math.min(targetY, finishYRef.current - viewportHeight + 100));\r\n          cameraYRef.current += (clampedTarget - cameraYRef.current) * CAMERA.LERP_SPEED;\r\n        }\r\n\r\n        // Draw UI Overlays (Leaderboard & Progress)\r\n        // Ensure UI stays locked to the screen, unaffected by camera transform\r\n        ctx.restore();\r\n        ctx.save();\r\n\r\n        const top5 = sortedBalls.slice(-5).reverse(); // highest Y first\r\n        drawLeaderboard(ctx, top5, courseWidth, size.width);\r\n\r\n        const progressY = leaderY > 0 ? leaderY : 0;\r\n        const totalDist = finishYRef.current - OBSTACLES.FIRST_ROW_Y;\r\n        const currentDist = progressY - OBSTACLES.FIRST_ROW_Y;\r\n        const progressPct = Math.max(0, Math.min(1, currentDist / totalDist));\r\n\r\n        drawProgressBar(ctx, progressPct, top5[0], courseWidth, viewportHeight);\r\n      }\r\n\r\n      ctx.restore();\r\n\r\n      animFrameRef.current = requestAnimationFrame(render);\r\n    };\r\n\r\n    animFrameRef.current = requestAnimationFrame(render);\r\n    return () => {\r\n      if (animFrameRef.current) cancelAnimationFrame(animFrameRef.current);\r\n    };\r\n  }, [size, onRaceFinish]);\r\n\r\n  return (\r\n    <div ref={containerRef} style={{ width: '100%', height: '100%', minHeight: '300px' }}>\r\n      <canvas\r\n        ref={canvasRef}\r\n        role=\"img\"\r\n        aria-label=\"Marble race course\"\r\n        style={{ width: '100%', height: '100%', display: 'block' }}\r\n      />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default memo(MarbleCanvas);\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\admin\\Documents\\Web Projects\\chooz-app\\src\\components\\MarbleRace\\MarbleConstants.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\admin\\Documents\\Web Projects\\chooz-app\\src\\components\\MarbleRace\\MarbleControls.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\admin\\Documents\\Web Projects\\chooz-app\\src\\components\\MarbleRace\\MarbleDrawing.js","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'padding' is assigned a value but never used. Allowed unused vars must match /^[A-Z_]/u.","line":368,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":368,"endColumn":16,"suggestions":[{"messageId":"removeVar","data":{"varName":"padding"},"fix":{"range":[11130,11149],"text":""},"desc":"Remove unused variable 'padding'."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { COLORS, OBSTACLES, COURSE } from './MarbleConstants';\r\n\r\n/**\r\n * Truncates text to fit within maxWidth.\r\n */\r\nconst truncateLabel = (ctx, text, maxWidth) => {\r\n  if (ctx.measureText(text).width <= maxWidth) return text;\r\n  let len = text.length;\r\n  while (len > 0) {\r\n    const truncated = text.substring(0, len) + '..';\r\n    if (ctx.measureText(truncated).width <= maxWidth) return truncated;\r\n    len--;\r\n  }\r\n  return '';\r\n};\r\n\r\n/**\r\n * Draws a single ball with its name label.\r\n */\r\nexport const drawBall = (ctx, ball, cameraY, viewportHeight, isLeader, viewportWidth) => {\r\n  const screenY = ball.y - cameraY;\r\n  if (screenY < -30 || screenY > viewportHeight + 30) return;\r\n\r\n  ctx.save();\r\n\r\n  // Leader glow\r\n  if (isLeader && !ball.finished) {\r\n    ctx.beginPath();\r\n    ctx.arc(ball.x, screenY, ball.radius + 4, 0, Math.PI * 2);\r\n    ctx.fillStyle = COLORS.LEADER_GLOW;\r\n    ctx.fill();\r\n  }\r\n\r\n  // Ball body with gradient\r\n  const ballGrad = ctx.createRadialGradient(\r\n    ball.x - ball.radius * 0.3, screenY - ball.radius * 0.3, ball.radius * 0.1,\r\n    ball.x, screenY, ball.radius,\r\n  );\r\n  ballGrad.addColorStop(0, lightenColor(ball.color, 40));\r\n  ballGrad.addColorStop(1, ball.color);\r\n  ctx.beginPath();\r\n  ctx.arc(ball.x, screenY, ball.radius, 0, Math.PI * 2);\r\n  ctx.fillStyle = ballGrad;\r\n  ctx.fill();\r\n\r\n  // Ball highlight\r\n  ctx.beginPath();\r\n  ctx.arc(ball.x - ball.radius * 0.25, screenY - ball.radius * 0.25, ball.radius * 0.3, 0, Math.PI * 2);\r\n  ctx.fillStyle = 'rgba(255,255,255,0.35)';\r\n  ctx.fill();\r\n\r\n  // Name label\r\n  const isMobile = viewportWidth && viewportWidth < 600;\r\n\r\n  // Scale down font on mobile\r\n  const fontMultiplier = isMobile ? 0.65 : 0.9;\r\n  const fontSize = Math.max(isMobile ? 5 : 7, ball.radius * fontMultiplier);\r\n\r\n  ctx.font = `700 ${fontSize}px sans-serif`;\r\n  ctx.textAlign = 'center';\r\n  ctx.textBaseline = 'middle';\r\n  ctx.fillStyle = COLORS.BALL_LABEL;\r\n\r\n  // Truncate more aggressively on mobile\r\n  const maxLabelWidthMultiplier = isMobile ? 1.5 : 2.5;\r\n  const maxLabelWidth = ball.radius * maxLabelWidthMultiplier;\r\n  const label = truncateLabel(ctx, ball.name, maxLabelWidth);\r\n\r\n  ctx.fillText(label, ball.x, screenY + ball.radius + fontSize + 2);\r\n\r\n  ctx.restore();\r\n};\r\n\r\n/**\r\n * Draws a fading spark particle.\r\n */\r\nexport const drawParticle = (ctx, particle, cameraY, viewportHeight) => {\r\n  const screenY = particle.y - cameraY;\r\n  if (screenY < -10 || screenY > viewportHeight + 10) return;\r\n\r\n  ctx.save();\r\n  ctx.globalAlpha = Math.max(0, particle.life);\r\n  ctx.beginPath();\r\n  const radius = Math.max(0.5, 4 * Math.sqrt(particle.life));\r\n  ctx.arc(particle.x, screenY, radius, 0, Math.PI * 2);\r\n\r\n  if (particle.color === '#4ade80') {\r\n    // Give green booster sparks a slight glow\r\n    ctx.shadowColor = particle.color;\r\n    ctx.shadowBlur = 4;\r\n  }\r\n\r\n  ctx.fillStyle = particle.color;\r\n  ctx.fill();\r\n  ctx.restore();\r\n};\r\n\r\n/**\r\n * Draws a peg with a 3D radial gradient and drop shadow.\r\n */\r\nconst drawPeg = (ctx, obstacle, screenY) => {\r\n  const { x, radius } = obstacle;\r\n\r\n  // Drop shadow\r\n  ctx.beginPath();\r\n  ctx.arc(x + 1, screenY + 2, radius + 1, 0, Math.PI * 2);\r\n  ctx.fillStyle = COLORS.PEG_SHADOW;\r\n  ctx.fill();\r\n\r\n  // Gradient body\r\n  const grad = ctx.createRadialGradient(\r\n    x - radius * 0.3, screenY - radius * 0.3, radius * 0.1,\r\n    x, screenY, radius,\r\n  );\r\n  grad.addColorStop(0, COLORS.PEG_HIGHLIGHT);\r\n  grad.addColorStop(1, COLORS.PEG);\r\n  ctx.beginPath();\r\n  ctx.arc(x, screenY, radius, 0, Math.PI * 2);\r\n  ctx.fillStyle = grad;\r\n  ctx.fill();\r\n};\r\n\r\n\r\n\r\n/**\r\n * Draws a funnel line segment with a gradient stroke.\r\n */\r\nconst drawFunnel = (ctx, obstacle, screenY, cameraY) => {\r\n  const screenY2 = obstacle.y2 - cameraY;\r\n\r\n  // Shadow line\r\n  ctx.beginPath();\r\n  ctx.moveTo(obstacle.x + 1, screenY + 2);\r\n  ctx.lineTo(obstacle.x2 + 1, screenY2 + 2);\r\n  ctx.strokeStyle = COLORS.FUNNEL_SHADOW;\r\n  ctx.lineWidth = (obstacle.thickness || 4) + 2;\r\n  ctx.lineCap = 'round';\r\n  ctx.stroke();\r\n\r\n  // Main gradient stroke\r\n  const grad = ctx.createLinearGradient(obstacle.x, screenY, obstacle.x2, screenY2);\r\n  grad.addColorStop(0, COLORS.FUNNEL);\r\n  grad.addColorStop(1, COLORS.BUMPER_TOP);\r\n  ctx.beginPath();\r\n  ctx.moveTo(obstacle.x, screenY);\r\n  ctx.lineTo(obstacle.x2, screenY2);\r\n  ctx.strokeStyle = grad;\r\n  ctx.lineWidth = obstacle.thickness || 4;\r\n  ctx.lineCap = 'round';\r\n  ctx.stroke();\r\n};\r\n\r\n/**\r\n * Draws a zigzag shelf segment with thick gradient line and rounded ends.\r\n */\r\nconst drawZigzag = (ctx, obstacle, screenY, cameraY) => {\r\n  const screenY2 = obstacle.y2 - cameraY;\r\n\r\n  // Shadow\r\n  ctx.beginPath();\r\n  ctx.moveTo(obstacle.x + 1, screenY + 2);\r\n  ctx.lineTo(obstacle.x2 + 1, screenY2 + 2);\r\n  ctx.strokeStyle = COLORS.FUNNEL_SHADOW;\r\n  ctx.lineWidth = (obstacle.thickness || 6) + 2;\r\n  ctx.lineCap = 'round';\r\n  ctx.stroke();\r\n\r\n  // Main shelf\r\n  const grad = ctx.createLinearGradient(obstacle.x, screenY, obstacle.x2, screenY2);\r\n  grad.addColorStop(0, COLORS.ZIGZAG_TOP);\r\n  grad.addColorStop(1, COLORS.ZIGZAG);\r\n  ctx.beginPath();\r\n  ctx.moveTo(obstacle.x, screenY);\r\n  ctx.lineTo(obstacle.x2, screenY2);\r\n  ctx.strokeStyle = grad;\r\n  ctx.lineWidth = obstacle.thickness || 6;\r\n  ctx.lineCap = 'round';\r\n  ctx.stroke();\r\n};\r\n\r\n/**\r\n * Draws the spinner's decorative ring (pegs drawn separately as normal pegs).\r\n */\r\nconst drawSpinnerRing = (ctx, obstacle, screenY) => {\r\n  ctx.beginPath();\r\n  ctx.arc(obstacle.x, screenY, obstacle.radius, 0, Math.PI * 2);\r\n  ctx.strokeStyle = COLORS.SPINNER_RING;\r\n  ctx.lineWidth = 2;\r\n  ctx.setLineDash([4, 6]);\r\n  ctx.stroke();\r\n  ctx.setLineDash([]);\r\n};\r\n\r\n/**\r\n * Draws a sliding sweeper.\r\n */\r\nconst drawSlider = (ctx, obstacle, screenY) => {\r\n  const width = obstacle.width;\r\n  const height = obstacle.height;\r\n\r\n  // Base block\r\n  ctx.fillStyle = '#f59e0b'; // Amber warning color\r\n  ctx.fillRect(obstacle.x, screenY, width, height);\r\n\r\n  // Hazard stripes\r\n  ctx.save();\r\n  ctx.beginPath();\r\n  ctx.rect(obstacle.x, screenY, width, height);\r\n  ctx.clip();\r\n\r\n  ctx.lineWidth = 6;\r\n  ctx.strokeStyle = '#b45309'; // Darker amber\r\n\r\n  for (let i = -width; i < width * 2; i += 16) {\r\n    ctx.beginPath();\r\n    ctx.moveTo(obstacle.x + i, screenY);\r\n    ctx.lineTo(obstacle.x + i - height, screenY + height);\r\n    ctx.stroke();\r\n  }\r\n  ctx.restore();\r\n\r\n  // Depth shadow\r\n  ctx.fillStyle = 'rgba(0,0,0,0.3)';\r\n  ctx.fillRect(obstacle.x, screenY + height, width, 4);\r\n};\r\n\r\n/**\r\n * Draws a glowing booster pad that shoots balls upward.\r\n */\r\nconst drawBoosterPad = (ctx, obstacle, screenY) => {\r\n  const { x, width, height } = obstacle;\r\n\r\n  // Outer glow\r\n  ctx.shadowColor = '#4ade80'; // Neon green\r\n  ctx.shadowBlur = 15;\r\n  ctx.fillStyle = '#22c55e'; // Core green\r\n\r\n  // Pad base with rounded top corners\r\n  ctx.beginPath();\r\n  ctx.roundRect(x, screenY, width, height, [8, 8, 2, 2]);\r\n  ctx.fill();\r\n\r\n  ctx.shadowBlur = 0;\r\n\r\n  // Bright inner highlight\r\n  ctx.fillStyle = '#bbf7d0';\r\n  ctx.beginPath();\r\n  ctx.roundRect(x + 4, screenY + 2, width - 8, height - 6, [4, 4, 1, 1]);\r\n  ctx.fill();\r\n\r\n  // Upward chevrons\r\n  ctx.fillStyle = '#14532d'; // Dark green text\r\n  ctx.textAlign = 'center';\r\n  ctx.textBaseline = 'middle';\r\n  ctx.font = 'bold 12px sans-serif';\r\n  ctx.fillText('>>>', x + width / 2, screenY + height / 2 + 1); // Using >>> rotated is hard, let's just draw lines\r\n\r\n  // Actually, let's just use text ^^^\r\n  ctx.fillText('Ôçí Ôçí Ôçí', x + width / 2, screenY + height / 2 + 1);\r\n};\r\n\r\n/**\r\n * Draws an obstacle relative to the camera.\r\n */\r\nexport const drawObstacle = (ctx, obstacle, cameraY, viewportHeight) => {\r\n  const screenY = obstacle.y - cameraY;\r\n\r\n  // Skip if off-screen\r\n  const obsHeight = obstacle.height || obstacle.radius || OBSTACLES.FUNNEL_HEIGHT;\r\n  if (screenY > viewportHeight + obsHeight + 20 || screenY < -obsHeight - 60) return;\r\n\r\n  ctx.save();\r\n\r\n  if (obstacle.type === 'peg' || obstacle.type === 'spinner_peg') {\r\n    drawPeg(ctx, obstacle, screenY);\r\n  } else if (obstacle.type === 'funnel_left' || obstacle.type === 'funnel_right') {\r\n    drawFunnel(ctx, obstacle, screenY, cameraY);\r\n  } else if (obstacle.type === 'zigzag_left' || obstacle.type === 'zigzag_right') {\r\n    drawZigzag(ctx, obstacle, screenY, cameraY);\r\n  } else if (obstacle.type === 'spinner_ring') {\r\n    drawSpinnerRing(ctx, obstacle, screenY);\r\n  } else if (obstacle.type === 'slider' || obstacle.type === 'trapdoor_block') {\r\n    drawSlider(ctx, obstacle, screenY);\r\n  } else if (obstacle.type === 'booster_pad') {\r\n    drawBoosterPad(ctx, obstacle, screenY);\r\n  }\r\n\r\n  ctx.restore();\r\n};\r\n\r\n/**\r\n * Draws the course walls.\r\n */\r\nexport const drawWalls = (ctx, courseWidth, cameraY, viewportHeight) => {\r\n  // Gradient walls for depth\r\n  const wallGrad = ctx.createLinearGradient(0, 0, COURSE.WALL_THICKNESS, 0);\r\n  wallGrad.addColorStop(0, '#475569');\r\n  wallGrad.addColorStop(1, COLORS.WALL);\r\n\r\n  ctx.fillStyle = wallGrad;\r\n  ctx.fillRect(0, 0, COURSE.WALL_THICKNESS, viewportHeight);\r\n\r\n  const wallGradR = ctx.createLinearGradient(courseWidth - COURSE.WALL_THICKNESS, 0, courseWidth, 0);\r\n  wallGradR.addColorStop(0, COLORS.WALL);\r\n  wallGradR.addColorStop(1, '#475569');\r\n\r\n  ctx.fillStyle = wallGradR;\r\n  ctx.fillRect(courseWidth - COURSE.WALL_THICKNESS, 0, COURSE.WALL_THICKNESS, viewportHeight);\r\n};\r\n\r\n/**\r\n * Draws the finish line.\r\n */\r\nexport const drawFinishLine = (ctx, finishY, cameraY, courseWidth, viewportHeight) => {\r\n  const screenY = finishY - cameraY;\r\n  if (screenY < -COURSE.FINISH_LINE_HEIGHT || screenY > viewportHeight + 20) return;\r\n\r\n  ctx.save();\r\n\r\n  // Checkerboard pattern\r\n  const squareSize = 10;\r\n  const numSquares = Math.ceil(courseWidth / squareSize);\r\n  for (let i = 0; i < numSquares; i++) {\r\n    for (let row = 0; row < 2; row++) {\r\n      ctx.fillStyle = (i + row) % 2 === 0 ? '#fff' : '#222';\r\n      ctx.fillRect(i * squareSize, screenY + row * squareSize, squareSize, squareSize);\r\n    }\r\n  }\r\n\r\n  // \"FINISH\" text\r\n  ctx.font = '700 14px sans-serif';\r\n  ctx.textAlign = 'center';\r\n  ctx.textBaseline = 'middle';\r\n  ctx.fillStyle = COLORS.FINISH_LINE;\r\n  ctx.fillText('FINISH', courseWidth / 2, screenY + squareSize + 30);\r\n\r\n  ctx.restore();\r\n};\r\n\r\n/**\r\n * Draws the course background.\r\n */\r\nexport const drawBackground = (ctx, courseWidth, viewportHeight) => {\r\n  ctx.fillStyle = COLORS.COURSE_BG;\r\n  ctx.fillRect(0, 0, courseWidth, viewportHeight);\r\n};\r\n\r\n/**\r\n * Lightens a hex color by a given amount.\r\n * @param {string} hex - Hex color string.\r\n * @param {number} amount - Amount to lighten (0-255).\r\n * @returns {string} Lightened hex color.\r\n */\r\nconst lightenColor = (hex, amount) => {\r\n  const num = parseInt(hex.replace('#', ''), 16);\r\n  const r = Math.min(255, (num >> 16) + amount);\r\n  const g = Math.min(255, ((num >> 8) & 0x00FF) + amount);\r\n  const b = Math.min(255, (num & 0x0000FF) + amount);\r\n  return `#${(r << 16 | g << 8 | b).toString(16).padStart(6, '0')}`;\r\n};\r\n\r\n/**\r\n * Draws the real-time leaderboard overlay in the top right.\r\n */\r\nexport const drawLeaderboard = (ctx, topBalls, courseWidth) => {\r\n  if (topBalls.length === 0) return;\r\n\r\n  const padding = 10;\r\n  const width = 130;\r\n  const startX = courseWidth - width - 15;\r\n  const startY = 15;\r\n\r\n  ctx.save();\r\n  // Highly-transparent background\r\n  ctx.fillStyle = 'rgba(15, 23, 42, 0.35)'; // Slate 900\r\n  ctx.shadowColor = 'rgba(0,0,0,0.2)';\r\n  ctx.shadowBlur = 4;\r\n  ctx.shadowOffsetY = 2;\r\n\r\n  // Rounded rect\r\n  ctx.beginPath();\r\n  ctx.roundRect(startX, startY, width, 26 + topBalls.length * 26, 6);\r\n  ctx.fill();\r\n\r\n  ctx.shadowColor = 'transparent';\r\n\r\n  // Title\r\n  ctx.fillStyle = 'rgba(255, 255, 255, 0.4)'; // highly muted mute\r\n  ctx.font = 'bold 10px Inter, sans-serif';\r\n  ctx.textAlign = 'center';\r\n  ctx.fillText('LEADERBOARD', startX + width / 2, startY + 16);\r\n\r\n  // Entries\r\n  ctx.textAlign = 'left';\r\n  topBalls.forEach((ball, index) => {\r\n    const y = startY + 38 + index * 26;\r\n\r\n    // Rank number (muted colors)\r\n    ctx.fillStyle = index === 0 ? 'rgba(251, 191, 36, 0.8)' :\r\n      index === 1 ? 'rgba(203, 213, 225, 0.8)' :\r\n        index === 2 ? 'rgba(180, 83, 9, 0.8)' :\r\n          'rgba(100, 116, 139, 0.8)';\r\n    ctx.font = 'bold 12px Inter, sans-serif';\r\n    ctx.fillText(`${index + 1}.`, startX + 12, y);\r\n\r\n    // Ball color swatch (smaller, no stroke)\r\n    ctx.beginPath();\r\n    ctx.arc(startX + 38, y - 4, 6, 0, Math.PI * 2);\r\n    ctx.fillStyle = ball.color;\r\n    ctx.fill();\r\n\r\n    // Name (muted white, shorter truncation)\r\n    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';\r\n    ctx.font = '12px Inter, sans-serif';\r\n    let displayName = ball.name;\r\n    if (ctx.measureText(displayName).width > 65) {\r\n      displayName = displayName.substring(0, 6) + '..';\r\n    }\r\n    ctx.fillText(displayName, startX + 54, y);\r\n  });\r\n\r\n  ctx.restore();\r\n};\r\n\r\n/**\r\n * Draws the vertical track progress bar on the right edge.\r\n */\r\nexport const drawProgressBar = (ctx, progressPct, leaderBall, courseWidth, viewportHeight) => {\r\n  if (!leaderBall) return;\r\n\r\n  const barWidth = 4;\r\n  const startX = 0; // Absolute left edge over the wall\r\n  const startY = 0;\r\n  const height = viewportHeight;\r\n\r\n  ctx.save();\r\n\r\n  // Track background \r\n  ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';\r\n  ctx.fillRect(startX, startY, barWidth, height);\r\n\r\n  // Progress fill (muted)\r\n  const fillHeight = Math.max(0, height * progressPct);\r\n  ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';\r\n  ctx.fillRect(startX, startY, barWidth, fillHeight);\r\n\r\n  // Leader marker (smaller, placed just outside the wall)\r\n  const markerY = startY + fillHeight;\r\n  ctx.beginPath();\r\n  ctx.arc(startX + barWidth + 2, markerY, 4, 0, Math.PI * 2);\r\n  ctx.fillStyle = leaderBall.color;\r\n  ctx.fill();\r\n\r\n  // Finish line marker at bottom\r\n  ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';\r\n  ctx.fillRect(startX, startY + height - 2, barWidth + 4, 2);\r\n\r\n  ctx.restore();\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\admin\\Documents\\Web Projects\\chooz-app\\src\\components\\MarbleRace\\MarbleGame.jsx","messages":[{"ruleId":"react-hooks/purity","severity":2,"message":"Error: Cannot call impure function during render\n\n`Date.now` is an impure function. Calling an impure function can produce unstable results that update unpredictably when the component happens to re-render. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#components-and-hooks-must-be-idempotent).\n\n  94 |       </ControlButtons>\n  95 |\n> 96 |       {results && winner && <Celebration key={winner.name + Date.now()} particleCount={20} />}\n     |                                                             ^^^^^^^^^^ Cannot call impure function\n  97 |\n  98 |       <GameContainer>\n  99 |         <CanvasWrapper>","line":96,"column":61,"nodeType":null,"endLine":96,"endColumn":71}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useCallback, useEffect, useState } from 'react';\r\nimport MarbleCanvas from './MarbleCanvas';\r\nimport MarbleControls from './MarbleControls';\r\nimport Celebration from '../Wheel/Celebration';\r\nimport { AnimatePresence } from 'framer-motion';\r\nimport { initAudio, setMuted, getMuted } from '../../utils/sounds';\r\nimport { ArrowLeftIcon, VolumeIcon, MuteIcon, CloseIcon, RefreshIcon } from '../common/Icons';\r\nimport {\r\n  PageContainer,\r\n  GameContainer,\r\n  FloatingNav,\r\n  ControlButtons,\r\n  NavButton,\r\n  MuteButton,\r\n  CanvasWrapper,\r\n  ModalBackdrop,\r\n  ResultsModal,\r\n  ResultsTitle,\r\n  WinnerName,\r\n  LeaderboardList,\r\n  LeaderboardEntry,\r\n  RankNumber,\r\n  ColorDot,\r\n  ButtonGroup,\r\n  ActionButton,\r\n  CloseButton,\r\n} from './MarbleGame.styles';\r\n\r\n/**\r\n * Marble Race game ÔÇö main component.\r\n * @param {object} props\r\n * @param {string[]} props.names - Shared name list.\r\n * @param {function} props.setNames - State setter for names.\r\n * @param {function} props.onBack - Navigate back to home.\r\n */\r\nconst MarbleGame = ({ names, setNames, onBack }) => {\r\n  const [isRacing, setIsRacing] = useState(false);\r\n  const [mode, setMode] = useState('first');\r\n  const [results, setResults] = useState(null);\r\n  const [isMuted, setIsMuted] = useState(getMuted());\r\n\r\n  const toggleMute = useCallback(() => {\r\n    const newMuted = !isMuted;\r\n    setMuted(newMuted);\r\n    setIsMuted(newMuted);\r\n  }, [isMuted]);\r\n\r\n  const handleStartRace = useCallback(() => {\r\n    if (names.length < 2) return;\r\n    initAudio();\r\n    setResults(null);\r\n    setIsRacing(true);\r\n  }, [names.length]);\r\n\r\n  const handleRaceFinish = useCallback((finishers) => {\r\n    setIsRacing(false);\r\n    setResults(finishers);\r\n  }, []);\r\n\r\n  const handleRaceAgain = useCallback(() => {\r\n    setResults(null);\r\n    setTimeout(() => handleStartRace(), 150);\r\n  }, [handleStartRace]);\r\n\r\n  useEffect(() => {\r\n    const handleKeyDown = (event) => {\r\n      if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') return;\r\n      if (event.code === 'Space' && !isRacing && !results && names.length > 1) {\r\n        event.preventDefault();\r\n        handleStartRace();\r\n      }\r\n      if (event.code === 'Escape' && results) {\r\n        setResults(null);\r\n      }\r\n    };\r\n    window.addEventListener('keydown', handleKeyDown);\r\n    return () => window.removeEventListener('keydown', handleKeyDown);\r\n  }, [isRacing, results, names.length, handleStartRace]);\r\n\r\n  const winner = results && results.length > 0 ? results[0] : null;\r\n\r\n  return (\r\n    <PageContainer>\r\n      <FloatingNav>\r\n        <NavButton onClick={onBack}>\r\n          <ArrowLeftIcon size={16} /> Back\r\n        </NavButton>\r\n      </FloatingNav>\r\n\r\n      <ControlButtons>\r\n        <MuteButton onClick={toggleMute} title={isMuted ? 'Unmute' : 'Mute'}>\r\n          {isMuted ? <MuteIcon size={20} /> : <VolumeIcon size={20} />}\r\n        </MuteButton>\r\n      </ControlButtons>\r\n\r\n      {results && winner && <Celebration key={winner.name + Date.now()} particleCount={20} />}\r\n\r\n      <GameContainer>\r\n        <CanvasWrapper>\r\n          <MarbleCanvas\r\n            names={names}\r\n            racing={isRacing}\r\n            onRaceFinish={handleRaceFinish}\r\n            mode={mode}\r\n          />\r\n        </CanvasWrapper>\r\n\r\n        {!isRacing && (\r\n          <MarbleControls\r\n            names={names}\r\n            setNames={setNames}\r\n            onRace={handleStartRace}\r\n            isRacing={isRacing}\r\n            mode={mode}\r\n            setMode={setMode}\r\n          />\r\n        )}\r\n      </GameContainer>\r\n\r\n      <AnimatePresence>\r\n        {results && (\r\n          <ModalBackdrop\r\n            initial={{ opacity: 0 }}\r\n            animate={{ opacity: 1 }}\r\n            exit={{ opacity: 0 }}\r\n            onClick={() => setResults(null)}\r\n          >\r\n            <ResultsModal\r\n              initial={{ scale: 0.8, opacity: 0, y: 50 }}\r\n              animate={{ scale: 1, opacity: 1, y: 0 }}\r\n              exit={{ scale: 0.9, opacity: 0 }}\r\n              transition={{ duration: 0.4, ease: 'easeOut' }}\r\n              onClick={(e) => e.stopPropagation()}\r\n            >\r\n              <CloseButton onClick={() => setResults(null)} aria-label=\"Close\">\r\n                <CloseIcon size={14} />\r\n              </CloseButton>\r\n\r\n              {mode === 'first' && winner && (\r\n                <>\r\n                  <ResultsTitle>We have a winner!</ResultsTitle>\r\n                  <WinnerName\r\n                    initial={{ scale: 0.9 }}\r\n                    animate={{ scale: 1 }}\r\n                    transition={{ duration: 0.3, delay: 0.2 }}\r\n                  >\r\n                    {winner.name}\r\n                  </WinnerName>\r\n                </>\r\n              )}\r\n\r\n              {mode === 'ranked' && (\r\n                <>\r\n                  <ResultsTitle>Race Results</ResultsTitle>\r\n                  <LeaderboardList>\r\n                    {results.map((ball) => (\r\n                      <LeaderboardEntry key={ball.id} $rank={ball.finishOrder}>\r\n                        <RankNumber>#{ball.finishOrder}</RankNumber>\r\n                        <ColorDot $color={ball.color} />\r\n                        <span style={{ flex: 1 }}>{ball.name}</span>\r\n                      </LeaderboardEntry>\r\n                    ))}\r\n                  </LeaderboardList>\r\n                </>\r\n              )}\r\n\r\n              <ButtonGroup>\r\n                <ActionButton onClick={handleRaceAgain}>\r\n                  <RefreshIcon size={14} /> Race Again\r\n                </ActionButton>\r\n              </ButtonGroup>\r\n            </ResultsModal>\r\n          </ModalBackdrop>\r\n        )}\r\n      </AnimatePresence>\r\n    </PageContainer>\r\n  );\r\n};\r\n\r\nexport default MarbleGame;\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\admin\\Documents\\Web Projects\\chooz-app\\src\\components\\MarbleRace\\MarbleGame.styles.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\admin\\Documents\\Web Projects\\chooz-app\\src\\components\\MarbleRace\\MarbleObstacles.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\admin\\Documents\\Web Projects\\chooz-app\\src\\components\\MarbleRace\\MarblePhysics.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\admin\\Documents\\Web Projects\\chooz-app\\src\\components\\Wheel\\Celebration.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\admin\\Documents\\Web Projects\\chooz-app\\src\\components\\Wheel\\Controls.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\admin\\Documents\\Web Projects\\chooz-app\\src\\components\\Wheel\\Controls.styles.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\admin\\Documents\\Web Projects\\chooz-app\\src\\components\\Wheel\\ControlsUtils.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\admin\\Documents\\Web Projects\\chooz-app\\src\\components\\Wheel\\ListModals.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\admin\\Documents\\Web Projects\\chooz-app\\src\\components\\Wheel\\WheelCanvas.jsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The 'effectiveNames' conditional could make the dependencies of useEffect Hook (at line 128) change on every render. To fix this, wrap the initialization of 'effectiveNames' in its own useMemo() Hook.","line":45,"column":9,"nodeType":"VariableDeclarator","endLine":45,"endColumn":71},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The 'effectiveNames' conditional could make the dependencies of useEffect Hook (at line 243) change on every render. To fix this, wrap the initialization of 'effectiveNames' in its own useMemo() Hook.","line":45,"column":9,"nodeType":"VariableDeclarator","endLine":45,"endColumn":71},{"ruleId":"no-unused-vars","severity":2,"message":"'hubRadius' is assigned a value but never used. Allowed unused vars must match /^[A-Z_]/u.","line":171,"column":50,"nodeType":"Identifier","messageId":"unusedVar","endLine":171,"endColumn":59,"suggestions":[{"messageId":"removeVar","data":{"varName":"hubRadius"},"fix":{"range":[6386,6397],"text":""},"desc":"Remove unused variable 'hubRadius'."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'isDemo'. Either include it or remove the dependency array.","line":330,"column":6,"nodeType":"ArrayExpression","endLine":330,"endColumn":96,"suggestions":[{"desc":"Update the dependencies array to be: [mustSpin, prizeNumber, names.length, effectiveNames.length, onStopSpinning, spinDuration, isDemo]","fix":{"range":[12495,12585],"text":"[mustSpin, prizeNumber, names.length, effectiveNames.length, onStopSpinning, spinDuration, isDemo]"}}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useRef, useEffect, useState, memo } from 'react';\r\nimport { GAME_COLORS } from '../../utils/colors';\r\nimport { playTick, playWin, initAudio } from '../../utils/sounds';\r\nimport { DRAWING_CONSTANTS } from './WheelConstants';\r\nimport {\r\n  drawHub,\r\n  drawPointer,\r\n  drawActiveLabel,\r\n  drawSegment\r\n} from './WheelDrawing';\r\n\r\nconst {\r\n  IDLE_ROTATION_SPEED,\r\n  HUB_RADIUS_RATIO,\r\n  MIN_HUB_RADIUS_PX,\r\n  SHADOW_BLUR_PX,\r\n  TOP_RESERVED_RATIO,\r\n  MIN_TOP_RESERVED_PX,\r\n  BOTTOM_PADDING_PX,\r\n  SIDE_PADDING_PX,\r\n  EASING_BASE,\r\n  EASING_EXPONENT_FACTOR,\r\n  MIN_EXTRA_ROTATIONS,\r\n  EXTRA_ROTATION_MULTIPLIER,\r\n  RANDOM_OFFSET_RANGE,\r\n  TICK_MIN_PITCH,\r\n  TICK_PITCH_RANGE,\r\n  TICK_SPEED_THRESHOLD,\r\n  PLACEHOLDER_TEXT,\r\n} = DRAWING_CONSTANTS;\r\n\r\nconst TWO_PI = 2 * Math.PI;\r\nconst THREE_HALF_PI = 3 * Math.PI / 2;\r\n\r\n/**\r\n * Applies an exponential ease-out curve for smooth spin deceleration.\r\n * @param {number} progress - Normalized progress value from 0 to 1.\r\n * @returns {number} The eased value from 0 to 1.\r\n */\r\nconst applyEasing = (progress) => {\r\n  return progress === 1 ? 1 : 1 - Math.pow(EASING_BASE, EASING_EXPONENT_FACTOR * progress);\r\n};\r\n\r\nconst WheelCanvas = ({ names, mustSpin, prizeNumber, onStopSpinning, onSpin, spinDuration = 5 }) => {\r\n  const effectiveNames = names.length > 0 ? names : [PLACEHOLDER_TEXT];\r\n  const isDemo = names.length === 0;\r\n\r\n  const canvasRef = useRef(null);\r\n  const containerRef = useRef(null);\r\n  const rotationRef = useRef(0);\r\n  const animationFrameId = useRef(null);\r\n  const isSpinningRef = useRef(false);\r\n  const hasFinishedSpinningRef = useRef(false);\r\n  const speedRef = useRef(0);\r\n  const geometryRef = useRef({ centerX: 0, centerY: 0, hubRadius: 0, effectiveRadius: 0, devicePixelRatio: 1, topReservedPixels: 0 });\r\n  const lastSegmentRef = useRef(-1);\r\n  const lastActiveColorRef = useRef(null);\r\n\r\n  const mustSpinRef = useRef(mustSpin);\r\n  useEffect(() => {\r\n    mustSpinRef.current = mustSpin;\r\n  }, [mustSpin]);\r\n\r\n  const prizeNumberRef = useRef(prizeNumber);\r\n  useEffect(() => {\r\n    prizeNumberRef.current = prizeNumber;\r\n  }, [prizeNumber]);\r\n\r\n  const [size, setSize] = useState({ width: 0, height: 0 });\r\n  const offscreenCanvasRef = useRef(null);\r\n  const hubCanvasRef = useRef(null);\r\n  const pointerCanvasRef = useRef(null);\r\n\r\n  useEffect(() => {\r\n    if (!containerRef.current) return;\r\n\r\n    const resizeObserver = new ResizeObserver((entries) => {\r\n      for (const entry of entries) {\r\n        const { width, height } = entry.contentRect;\r\n        setSize({ width, height });\r\n      }\r\n    });\r\n\r\n    resizeObserver.observe(containerRef.current);\r\n    return () => resizeObserver.disconnect();\r\n  }, []);\r\n\r\n  // Pre-render segments to offscreen canvas (only when names or size change)\r\n  useEffect(() => {\r\n    if (size.width === 0 || size.height === 0) return;\r\n\r\n    const canvas = canvasRef.current;\r\n    const devicePixelRatio = window.devicePixelRatio || 1;\r\n\r\n    canvas.width = size.width * devicePixelRatio;\r\n    canvas.height = size.height * devicePixelRatio;\r\n\r\n    const topReservedPixels = Math.max(MIN_TOP_RESERVED_PX * devicePixelRatio, canvas.height * TOP_RESERVED_RATIO);\r\n    const availableHeight = canvas.height - topReservedPixels - (BOTTOM_PADDING_PX * devicePixelRatio);\r\n    const availableWidth = canvas.width - (SIDE_PADDING_PX * devicePixelRatio);\r\n    const diameter = Math.min(availableWidth, availableHeight);\r\n    const effectiveRadius = diameter / 2;\r\n    const centerX = canvas.width / 2;\r\n    const centerY = topReservedPixels + effectiveRadius;\r\n    const hubRadius = Math.max(MIN_HUB_RADIUS_PX * devicePixelRatio, effectiveRadius * HUB_RADIUS_RATIO);\r\n\r\n    geometryRef.current = { centerX, centerY, hubRadius, effectiveRadius, devicePixelRatio, topReservedPixels };\r\n\r\n    // Pre-render wheel segments\r\n    const offscreen = document.createElement('canvas');\r\n    offscreen.width = canvas.width;\r\n    offscreen.height = canvas.height;\r\n    const offCtx = offscreen.getContext('2d');\r\n    offCtx.clearRect(0, 0, offscreen.width, offscreen.height);\r\n\r\n    const center = { x: centerX, y: centerY };\r\n    effectiveNames.forEach((name, index) => {\r\n      drawSegment(offCtx, name, index, effectiveNames.length, effectiveRadius, hubRadius, GAME_COLORS, center, devicePixelRatio);\r\n    });\r\n    offscreenCanvasRef.current = offscreen;\r\n\r\n    // Pre-render hub and pointer for every possible color to avoid per-frame shadow cost\r\n    // Instead we'll cache the last-used color and only rebuild when it changes\r\n    hubCanvasRef.current = null;\r\n    pointerCanvasRef.current = null;\r\n    lastActiveColorRef.current = null;\r\n\r\n  }, [names, size, effectiveNames, isDemo]);\r\n\r\n  // Pre-render hub for a given color\r\n  const getHubCanvas = (activeColor) => {\r\n    if (lastActiveColorRef.current === activeColor && hubCanvasRef.current) {\r\n      return hubCanvasRef.current;\r\n    }\r\n    const { hubRadius, effectiveRadius, devicePixelRatio } = geometryRef.current;\r\n    const hubSize = (hubRadius + SHADOW_BLUR_PX * devicePixelRatio + 10) * 2;\r\n\r\n    const hubCanvas = document.createElement('canvas');\r\n    hubCanvas.width = hubSize;\r\n    hubCanvas.height = hubSize;\r\n    const hubCtx = hubCanvas.getContext('2d');\r\n    hubCtx.translate(hubSize / 2, hubSize / 2);\r\n    drawHub(hubCtx, hubRadius, devicePixelRatio, activeColor);\r\n    hubCanvasRef.current = hubCanvas;\r\n\r\n    const pointerCanvas = document.createElement('canvas');\r\n    const pointerWidth = 100 * devicePixelRatio;\r\n    const pointerHeight = (effectiveRadius + 80) * devicePixelRatio;\r\n    pointerCanvas.width = pointerWidth;\r\n    pointerCanvas.height = pointerHeight;\r\n    const ptrCtx = pointerCanvas.getContext('2d');\r\n    ptrCtx.translate(pointerWidth / 2, pointerHeight);\r\n    drawPointer(ptrCtx, effectiveRadius, devicePixelRatio, activeColor);\r\n    pointerCanvasRef.current = pointerCanvas;\r\n\r\n    lastActiveColorRef.current = activeColor;\r\n    return hubCanvas;\r\n  };\r\n\r\n  // Main render loop\r\n  useEffect(() => {\r\n    if (size.width === 0 || size.height === 0) return;\r\n    if (!offscreenCanvasRef.current) return;\r\n\r\n    const canvas = canvasRef.current;\r\n    const canvasCtx = canvas.getContext('2d');\r\n    const segmentAngle = TWO_PI / effectiveNames.length;\r\n\r\n    const drawFrame = (timestamp) => {\r\n      if (!offscreenCanvasRef.current) return;\r\n      const { centerX, centerY, effectiveRadius, hubRadius, devicePixelRatio, topReservedPixels } = geometryRef.current;\r\n\r\n      canvasCtx.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n      // Idle rotation\r\n      if (!isSpinningRef.current && !hasFinishedSpinningRef.current && !mustSpinRef.current) {\r\n        rotationRef.current += IDLE_ROTATION_SPEED;\r\n      }\r\n\r\n      // Draw rotated wheel segments\r\n      canvasCtx.save();\r\n      canvasCtx.translate(centerX, centerY);\r\n      canvasCtx.rotate(rotationRef.current);\r\n      canvasCtx.translate(-centerX, -centerY);\r\n      canvasCtx.drawImage(offscreenCanvasRef.current, 0, 0);\r\n\r\n      // Winner highlight overlay\r\n      if (hasFinishedSpinningRef.current && prizeNumberRef.current !== null && !isDemo) {\r\n        canvasCtx.translate(centerX, centerY);\r\n        const alpha = 0.5 + 0.5 * Math.sin(timestamp / 200);\r\n        canvasCtx.beginPath();\r\n        canvasCtx.moveTo(0, 0);\r\n        canvasCtx.arc(0, 0, effectiveRadius, prizeNumberRef.current * segmentAngle, (prizeNumberRef.current + 1) * segmentAngle);\r\n        canvasCtx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.3})`;\r\n        canvasCtx.fill();\r\n        canvasCtx.translate(-centerX, -centerY);\r\n      }\r\n\r\n      canvasCtx.restore();\r\n\r\n      // Calculate active segment\r\n      const currentRotation = rotationRef.current;\r\n      let normalizedRotation = currentRotation % TWO_PI;\r\n      if (normalizedRotation < 0) normalizedRotation += TWO_PI;\r\n\r\n      let activeAngle = THREE_HALF_PI - normalizedRotation;\r\n      while (activeAngle < 0) activeAngle += TWO_PI;\r\n      activeAngle = activeAngle % TWO_PI;\r\n\r\n      const activeIndex = Math.floor(activeAngle / segmentAngle) % effectiveNames.length;\r\n      const activeColor = GAME_COLORS[activeIndex % GAME_COLORS.length];\r\n      const activeName = effectiveNames[activeIndex];\r\n\r\n      // Tick sound on segment change\r\n      if (isSpinningRef.current && lastSegmentRef.current !== -1 && lastSegmentRef.current !== activeIndex) {\r\n        const tickProgress = speedRef.current > 0 ? Math.min(1, speedRef.current / TICK_SPEED_THRESHOLD) : 0.5;\r\n        playTick(TICK_MIN_PITCH + tickProgress * TICK_PITCH_RANGE);\r\n      }\r\n      lastSegmentRef.current = activeIndex;\r\n\r\n      // Draw hub and pointer from cached offscreen canvases\r\n      const hubCanvas = getHubCanvas(activeColor);\r\n      canvasCtx.drawImage(hubCanvas, centerX - hubCanvas.width / 2, centerY - hubCanvas.height / 2);\r\n      canvasCtx.drawImage(pointerCanvasRef.current, centerX - pointerCanvasRef.current.width / 2, centerY - pointerCanvasRef.current.height);\r\n\r\n      // Active label (lightweight ÔÇö no shadow caching needed, text changes every segment)\r\n      canvasCtx.save();\r\n      canvasCtx.translate(centerX, 0);\r\n      drawActiveLabel(canvasCtx, activeName, activeColor, topReservedPixels, devicePixelRatio);\r\n      canvasCtx.restore();\r\n    };\r\n\r\n    const animate = (timestamp) => {\r\n      drawFrame(timestamp);\r\n      animationFrameId.current = requestAnimationFrame(animate);\r\n    };\r\n\r\n    animationFrameId.current = requestAnimationFrame(animate);\r\n\r\n    return () => {\r\n      if (animationFrameId.current) cancelAnimationFrame(animationFrameId.current);\r\n    };\r\n  }, [size, effectiveNames, isDemo]);\r\n\r\n  const handleCanvasClick = (event) => {\r\n    if (isDemo) return;\r\n    if (!onSpin || isSpinningRef.current || mustSpinRef.current) return;\r\n\r\n    const canvas = canvasRef.current;\r\n    if (!canvas) return;\r\n\r\n    const rect = canvas.getBoundingClientRect();\r\n    const clickX = (event.clientX - rect.left) * geometryRef.current.devicePixelRatio;\r\n    const clickY = (event.clientY - rect.top) * geometryRef.current.devicePixelRatio;\r\n\r\n    const deltaX = clickX - geometryRef.current.centerX;\r\n    const deltaY = clickY - geometryRef.current.centerY;\r\n    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\r\n\r\n    if (distance <= geometryRef.current.hubRadius) {\r\n      initAudio();\r\n      onSpin();\r\n    }\r\n  };\r\n\r\n  useEffect(() => {\r\n    if (mustSpin && !isSpinningRef.current) {\r\n      if (isDemo) {\r\n        onStopSpinning();\r\n        return;\r\n      }\r\n\r\n      isSpinningRef.current = true;\r\n      hasFinishedSpinningRef.current = false;\r\n\r\n      let start = null;\r\n      const duration = spinDuration * 1000;\r\n      const initialRotation = rotationRef.current;\r\n\r\n      const numSegments = effectiveNames.length;\r\n      const segAngle = TWO_PI / numSegments;\r\n      const randomOffset = (Math.random() - 0.5) * RANDOM_OFFSET_RANGE;\r\n      const segmentCenter = (prizeNumber + 0.5) * segAngle;\r\n      const targetAngleRaw = THREE_HALF_PI - segmentCenter + randomOffset;\r\n\r\n      let finalTarget = targetAngleRaw;\r\n      while (finalTarget < initialRotation) {\r\n        finalTarget += TWO_PI;\r\n      }\r\n      const extraRotations = Math.max(MIN_EXTRA_ROTATIONS, Math.floor(spinDuration * EXTRA_ROTATION_MULTIPLIER));\r\n      finalTarget += (extraRotations * TWO_PI);\r\n\r\n      const startRotation = initialRotation;\r\n      const totalDelta = finalTarget - startRotation;\r\n      let previousRotation = initialRotation;\r\n\r\n      const step = (timestamp) => {\r\n        if (!start) start = timestamp;\r\n\r\n        if (!mustSpinRef.current) {\r\n          rotationRef.current = finalTarget;\r\n          isSpinningRef.current = false;\r\n          hasFinishedSpinningRef.current = true;\r\n          speedRef.current = 0;\r\n          onStopSpinning();\r\n          return;\r\n        }\r\n\r\n        const progress = (timestamp - start) / duration;\r\n\r\n        if (progress < 1) {\r\n          const ease = applyEasing(progress);\r\n          const newRotation = startRotation + totalDelta * ease;\r\n          speedRef.current = Math.abs(newRotation - previousRotation);\r\n          previousRotation = newRotation;\r\n          rotationRef.current = newRotation;\r\n          requestAnimationFrame(step);\r\n        } else {\r\n          rotationRef.current = finalTarget;\r\n          isSpinningRef.current = false;\r\n          hasFinishedSpinningRef.current = true;\r\n          speedRef.current = 0;\r\n          playWin();\r\n          onStopSpinning();\r\n        }\r\n      };\r\n\r\n      requestAnimationFrame(step);\r\n    }\r\n  }, [mustSpin, prizeNumber, names.length, effectiveNames.length, onStopSpinning, spinDuration]);\r\n\r\n  return (\r\n    <div ref={containerRef} style={{ width: '100%', height: '100%', minHeight: '300px' }}>\r\n      <canvas\r\n        ref={canvasRef}\r\n        onClick={handleCanvasClick}\r\n        role=\"img\"\r\n        aria-label=\"Spin wheel with name segments\"\r\n        style={{ width: '100%', height: '100%', display: 'block', cursor: (mustSpin || isDemo) ? 'default' : 'pointer' }}\r\n      />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default memo(WheelCanvas);\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\admin\\Documents\\Web Projects\\chooz-app\\src\\components\\Wheel\\WheelConstants.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\admin\\Documents\\Web Projects\\chooz-app\\src\\components\\Wheel\\WheelDrawing.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\admin\\Documents\\Web Projects\\chooz-app\\src\\components\\Wheel\\WheelGame.jsx","messages":[{"ruleId":"react-hooks/purity","severity":2,"message":"Error: Cannot call impure function during render\n\n`Date.now` is an impure function. Calling an impure function can produce unstable results that update unpredictably when the component happens to re-render. (https://react.dev/reference/rules/components-and-hooks-must-be-pure#components-and-hooks-must-be-idempotent).\n\n  123 |       </ControlButtons>\n  124 |\n> 125 |       {winner && <Celebration key={winner + Date.now()} particleCount={20} />}\n      |                                             ^^^^^^^^^^ Cannot call impure function\n  126 |\n  127 |       <GameContainer>\n  128 |         <WheelWrapper>","line":125,"column":45,"nodeType":null,"endLine":125,"endColumn":55}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useCallback, useEffect, useRef, useState } from 'react';\r\nimport WheelCanvas from './WheelCanvas';\r\nimport Controls from './Controls';\r\nimport Celebration from './Celebration';\r\nimport { AnimatePresence } from 'framer-motion';\r\nimport { initAudio, setMuted, getMuted } from '../../utils/sounds';\r\nimport { ArrowLeftIcon, StopIcon, TrashIcon, VolumeIcon, MuteIcon, RefreshIcon, CloseIcon } from '../common/Icons';\r\nimport { useLocalStorage } from '../../hooks/useLocalStorage';\r\nimport {\r\n  GameContainer,\r\n  FloatingNav,\r\n  ControlButtons,\r\n  NavButton,\r\n  StopButton,\r\n  WheelWrapper,\r\n  ModalBackdrop,\r\n  WinnerModal,\r\n  WinnerTitle,\r\n  WinnerName,\r\n  ButtonGroup,\r\n  ActionButton,\r\n  RemoveButton,\r\n  ControlsWrapper,\r\n  PageContainer,\r\n  MuteButton,\r\n} from './WheelGame.styles';\r\n\r\nconst DEFAULT_SPIN_DURATION = 5;\r\nconst MAX_HISTORY_SIZE = 20;\r\n\r\nconst WheelGame = ({\r\n  names, setNames,\r\n  onBack,\r\n}) => {\r\n  const [mustSpin, setMustSpin] = useState(false);\r\n  const [prizeNumber, setPrizeNumber] = useState(0);\r\n  const [winner, setWinner] = useState(null);\r\n  const [spinDuration, setSpinDuration] = useState(DEFAULT_SPIN_DURATION);\r\n  const [history, setHistory] = useLocalStorage('chooz_history', []);\r\n  const [isMutedState, setIsMutedState] = useState(getMuted());\r\n  const isAbortingRef = useRef(false);\r\n\r\n  const toggleMute = useCallback(() => {\r\n    const newMuted = !isMutedState;\r\n    setMuted(newMuted);\r\n    setIsMutedState(newMuted);\r\n  }, [isMutedState]);\r\n\r\n  const handleSpinClick = useCallback(() => {\r\n    if (!mustSpin && names.length > 1) {\r\n      initAudio();\r\n      const newPrizeNumber = Math.floor(Math.random() * names.length);\r\n      setPrizeNumber(newPrizeNumber);\r\n      setMustSpin(true);\r\n      setWinner(null);\r\n    }\r\n  }, [mustSpin, names.length, setPrizeNumber, setMustSpin, setWinner]);\r\n\r\n  useEffect(() => {\r\n    const handleKeyDown = (event) => {\r\n      if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') return;\r\n      if (event.code === 'Space' && !mustSpin && !winner && names.length > 1) {\r\n        event.preventDefault();\r\n        handleSpinClick();\r\n      }\r\n      if (event.code === 'Escape' && winner) {\r\n        setWinner(null);\r\n      }\r\n    };\r\n    window.addEventListener('keydown', handleKeyDown);\r\n    return () => window.removeEventListener('keydown', handleKeyDown);\r\n  }, [mustSpin, winner, names.length, handleSpinClick]);\r\n\r\n  const handleStopSpinning = () => {\r\n    setMustSpin(false);\r\n    if (isAbortingRef.current) {\r\n      isAbortingRef.current = false;\r\n      setWinner(null);\r\n      return;\r\n    }\r\n    const newWinner = names[prizeNumber];\r\n    setWinner(newWinner);\r\n    setHistory(prev => [newWinner, ...prev].slice(0, MAX_HISTORY_SIZE));\r\n  };\r\n\r\n  const handleRemoveWinner = useCallback(() => {\r\n    if (winner) {\r\n      const indexToRemove = names.indexOf(winner);\r\n      const newNames = names.filter((_, index) => index !== indexToRemove);\r\n      setNames(newNames);\r\n      setWinner(null);\r\n    }\r\n  }, [winner, names, setNames, setWinner]);\r\n\r\n  const handleSpinAgain = useCallback(() => {\r\n    setWinner(null);\r\n    setTimeout(handleSpinClick, 100);\r\n  }, [setWinner, handleSpinClick]);\r\n\r\n  return (\r\n    <PageContainer>\r\n\r\n      <FloatingNav>\r\n        {mustSpin ? (\r\n          <StopButton onClick={() => {\r\n            isAbortingRef.current = true;\r\n            setMustSpin(false);\r\n          }}>\r\n            <StopIcon size={12} />\r\n            ABORT\r\n          </StopButton>\r\n        ) : (\r\n          <NavButton onClick={onBack}>\r\n            <ArrowLeftIcon size={16} /> Back\r\n          </NavButton>\r\n        )}\r\n      </FloatingNav>\r\n\r\n      <ControlButtons>\r\n        <MuteButton onClick={toggleMute} title={isMutedState ? \"Unmute\" : \"Mute\"}>\r\n          {isMutedState ? <MuteIcon size={20} /> : <VolumeIcon size={20} />}\r\n        </MuteButton>\r\n      </ControlButtons>\r\n\r\n      {winner && <Celebration key={winner + Date.now()} particleCount={20} />}\r\n\r\n      <GameContainer>\r\n        <WheelWrapper>\r\n          <WheelCanvas\r\n            names={names}\r\n            mustSpin={mustSpin}\r\n            prizeNumber={prizeNumber}\r\n            onStopSpinning={handleStopSpinning}\r\n            onSpin={handleSpinClick}\r\n            spinDuration={spinDuration}\r\n          />\r\n        </WheelWrapper>\r\n\r\n        <AnimatePresence mode=\"wait\">\r\n          {!mustSpin && (\r\n            <ControlsWrapper\r\n              initial={{ opacity: 0, y: 20 }}\r\n              animate={{ opacity: 1, y: 0 }}\r\n              exit={{ opacity: 0, y: 20, scale: 0.95 }}\r\n              transition={{ duration: 0.3, ease: 'easeOut' }}\r\n            >\r\n              <Controls\r\n                names={names}\r\n                setNames={setNames}\r\n                onSpin={handleSpinClick}\r\n                isSpinning={mustSpin}\r\n                spinDuration={spinDuration}\r\n                setSpinDuration={setSpinDuration}\r\n                history={history}\r\n              />\r\n            </ControlsWrapper>\r\n          )}\r\n        </AnimatePresence>\r\n      </GameContainer>\r\n\r\n      <AnimatePresence>\r\n        {winner && (\r\n          <ModalBackdrop\r\n            initial={{ opacity: 0 }}\r\n            animate={{ opacity: 1 }}\r\n            exit={{ opacity: 0 }}\r\n            onClick={() => setWinner(null)}\r\n          >\r\n            <WinnerModal\r\n              initial={{ scale: 0.8, opacity: 0, y: 50 }}\r\n              animate={{\r\n                scale: 1,\r\n                opacity: 1,\r\n                y: 0\r\n              }}\r\n              exit={{ scale: 0.9, opacity: 0 }}\r\n              transition={{ duration: 0.4, ease: \"easeOut\" }}\r\n              onClick={(event) => event.stopPropagation()}\r\n            >\r\n              <button\r\n                onClick={() => setWinner(null)}\r\n                style={{\r\n                  position: 'absolute', top: 12, right: 12,\r\n                  background: 'rgba(255,255,255,0.1)', border: 'none',\r\n                  borderRadius: '50%', width: 32, height: 32,\r\n                  display: 'flex', alignItems: 'center', justifyContent: 'center',\r\n                  cursor: 'pointer', color: 'rgba(255,255,255,0.6)',\r\n                  transition: 'background 0.2s, color 0.2s'\r\n                }}\r\n                onMouseEnter={e => { e.currentTarget.style.background = 'rgba(255,255,255,0.2)'; e.currentTarget.style.color = '#fff'; }}\r\n                onMouseLeave={e => { e.currentTarget.style.background = 'rgba(255,255,255,0.1)'; e.currentTarget.style.color = 'rgba(255,255,255,0.6)'; }}\r\n                aria-label=\"Close\"\r\n              >\r\n                <CloseIcon size={14} />\r\n              </button>\r\n              <WinnerTitle>We have a winner!</WinnerTitle>\r\n              <WinnerName\r\n                initial={{ scale: 0.9 }}\r\n                animate={{ scale: 1 }}\r\n                transition={{ duration: 0.3, delay: 0.2 }}\r\n              >\r\n                {winner}\r\n              </WinnerName>\r\n\r\n              <ButtonGroup>\r\n                <ActionButton onClick={handleSpinAgain}>\r\n                  <RefreshIcon size={14} /> Spin Again\r\n                </ActionButton>\r\n                <RemoveButton onClick={handleRemoveWinner}>\r\n                  <TrashIcon size={14} /> Remove\r\n                </RemoveButton>\r\n              </ButtonGroup>\r\n            </WinnerModal>\r\n          </ModalBackdrop>\r\n        )}\r\n      </AnimatePresence>\r\n    </PageContainer>\r\n  );\r\n};\r\n\r\nexport default WheelGame;\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\admin\\Documents\\Web Projects\\chooz-app\\src\\components\\Wheel\\WheelGame.styles.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\admin\\Documents\\Web Projects\\chooz-app\\src\\components\\common\\Button.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\admin\\Documents\\Web Projects\\chooz-app\\src\\components\\common\\Icons.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\admin\\Documents\\Web Projects\\chooz-app\\src\\components\\common\\Input.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\admin\\Documents\\Web Projects\\chooz-app\\src\\components\\common\\SharedNameControls.jsx","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'motion' is defined but never used. Allowed unused vars must match /^[A-Z_]/u.","line":2,"column":27,"nodeType":"Identifier","messageId":"unusedVar","endLine":2,"endColumn":33,"suggestions":[{"messageId":"removeVar","data":{"varName":"motion"},"fix":{"range":[72,80],"text":""},"desc":"Remove unused variable 'motion'."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useCallback } from 'react';\r\nimport { AnimatePresence, motion } from 'framer-motion';\r\nimport { GAME_COLORS } from '../../utils/colors';\r\nimport { playUiClick } from '../../utils/sounds';\r\nimport { ShuffleIcon, CloseIcon, PlusIcon, ClearAllIcon, ImportIcon, SaveIcon, HistoryIcon, EditIcon } from './Icons';\r\nimport { SaveModal, LoadModal } from '../Wheel/ListModals';\r\nimport { parseImportText, saveNewList, deleteListFromStorage } from '../Wheel/ControlsUtils';\r\nimport {\r\n  ControlsPanel,\r\n  Label,\r\n  NameListContainer,\r\n  NameItem,\r\n  ColorDot,\r\n  RemoveBtn,\r\n  ButtonRow,\r\n  IconButton,\r\n  WarningMessage,\r\n  EmptyState,\r\n  TextArea,\r\n  FlexInput,\r\n  FlexButton\r\n} from './SharedNameControls.styles';\r\n\r\nconst STORAGE_KEY = 'chooz_saved_lists';\r\nconst DUPLICATE_WARNING_TIMEOUT_MS = 3000;\r\n\r\n/**\r\n * SharedNameControls\r\n * A universal component for adding, editing, and managing a list of names.\r\n * Supports limits, lockouts during gameplay, colors, and local storage.\r\n *\r\n * @param {object} props\r\n * @param {string[]} props.names - Array of names.\r\n * @param {function} props.setNames - State setter for names.\r\n * @param {boolean} props.isLocked - Disables inputs when game is running.\r\n * @param {number} [props.maxNames=Infinity] - Maximum allowed names.\r\n * @param {boolean} [props.showColors=false] - Whether to show colored dots next to names.\r\n */\r\nconst SharedNameControls = ({ names, setNames, isLocked, maxNames = Infinity, showColors = false }) => {\r\n  const [newName, setNewName] = useState('');\r\n  const [isImportVisible, setIsImportVisible] = useState(false);\r\n  const [importMode, setImportMode] = useState('append');\r\n  const [importText, setImportText] = useState('');\r\n  const [savedLists, setSavedLists] = useState(() => {\r\n    const saved = localStorage.getItem(STORAGE_KEY);\r\n    return saved ? JSON.parse(saved) : [];\r\n  });\r\n  const [isSaveModalVisible, setIsSaveModalVisible] = useState(false);\r\n  const [listName, setListName] = useState('');\r\n  const [isLoadModalVisible, setIsLoadModalVisible] = useState(false);\r\n  const [duplicateWarning, setDuplicateWarning] = useState('');\r\n\r\n  const handleAdd = useCallback(() => {\r\n    playUiClick();\r\n    const trimmed = newName.trim();\r\n    if (trimmed) {\r\n      if (names.length >= maxNames) {\r\n        setDuplicateWarning(`Maximum limit of ${maxNames} names reached`);\r\n        setTimeout(() => setDuplicateWarning(''), DUPLICATE_WARNING_TIMEOUT_MS);\r\n        return;\r\n      }\r\n      if (names.some(name => name.toLowerCase() === trimmed.toLowerCase())) {\r\n        setDuplicateWarning(`\"${trimmed}\" is already in the list`);\r\n        setTimeout(() => setDuplicateWarning(''), DUPLICATE_WARNING_TIMEOUT_MS);\r\n        return;\r\n      }\r\n      setNames([...names, trimmed]);\r\n      setNewName('');\r\n      setDuplicateWarning('');\r\n    }\r\n  }, [newName, names, setNames, maxNames]);\r\n\r\n  const handleRemove = useCallback((targetIndex) => {\r\n    playUiClick();\r\n    setNames(prev => prev.filter((_, index) => index !== targetIndex));\r\n  }, [setNames]);\r\n\r\n  const handleKeyDown = (event) => {\r\n    if (event.key === 'Enter') handleAdd();\r\n  };\r\n\r\n  const handleShuffle = () => {\r\n    playUiClick();\r\n    const shuffled = [...names];\r\n    for (let index = shuffled.length - 1; index > 0; index--) {\r\n      const randomIndex = Math.floor(Math.random() * (index + 1));\r\n      [shuffled[index], shuffled[randomIndex]] = [shuffled[randomIndex], shuffled[index]];\r\n    }\r\n    setNames(shuffled);\r\n  };\r\n\r\n  const handleClearAll = () => {\r\n    if (names.length > 0 && window.confirm('Clear all names?')) {\r\n      playUiClick();\r\n      setNames([]);\r\n    }\r\n  };\r\n\r\n  const handleImport = () => {\r\n    const parsedNames = parseImportText(importText);\r\n    const uniqueNewNames = parsedNames.filter(\r\n      (name, index, arr) => arr.findIndex(n => n.toLowerCase() === name.toLowerCase()) === index\r\n    );\r\n\r\n    let resultingNames = [];\r\n    if (importMode === 'append') {\r\n      const filteredNew = uniqueNewNames.filter(\r\n        name => !names.some(existing => existing.toLowerCase() === name.toLowerCase())\r\n      );\r\n      resultingNames = [...names, ...filteredNew];\r\n    } else {\r\n      resultingNames = uniqueNewNames;\r\n    }\r\n\r\n    if (resultingNames.length > maxNames) {\r\n      setDuplicateWarning(`List capped at ${maxNames} names maximum`);\r\n      setTimeout(() => setDuplicateWarning(''), DUPLICATE_WARNING_TIMEOUT_MS);\r\n      setNames(resultingNames.slice(0, maxNames));\r\n    } else {\r\n      setNames(resultingNames);\r\n    }\r\n\r\n    setImportText('');\r\n    setIsImportVisible(false);\r\n  };\r\n\r\n  const handleSaveList = () => {\r\n    if (listName.trim() && names.length > 0) {\r\n      const updated = saveNewList(savedLists, listName, names, STORAGE_KEY);\r\n      setSavedLists(updated);\r\n      setListName('');\r\n      setIsSaveModalVisible(false);\r\n    }\r\n  };\r\n\r\n  const handleLoadList = (list) => {\r\n    setNames([...list.names]);\r\n    setIsLoadModalVisible(false);\r\n  };\r\n\r\n  const handleDeleteList = (listToDelete) => {\r\n    const updated = deleteListFromStorage(savedLists, listToDelete, STORAGE_KEY);\r\n    setSavedLists(updated);\r\n  };\r\n\r\n  return (\r\n    <ControlsPanel>\r\n      <ButtonRow>\r\n        <FlexInput\r\n          value={newName}\r\n          onChange={(event) => setNewName(event.target.value)}\r\n          onKeyDown={handleKeyDown}\r\n          placeholder={names.length >= maxNames ? `${maxNames} name limit reached` : \"Add a name...\"}\r\n          disabled={names.length >= maxNames || isLocked}\r\n          aria-label=\"Enter name to add\"\r\n        />\r\n        <IconButton onClick={handleAdd} disabled={names.length >= maxNames || isLocked} title=\"Add name\" aria-label=\"Add name\">\r\n          <PlusIcon size={16} />\r\n        </IconButton>\r\n      </ButtonRow>\r\n\r\n      {duplicateWarning && <WarningMessage role=\"alert\">{duplicateWarning}</WarningMessage>}\r\n\r\n      <ButtonRow role=\"toolbar\" aria-label=\"List actions\">\r\n        <IconButton onClick={handleShuffle} disabled={names.length < 2 || isLocked} title=\"Shuffle\" aria-label=\"Shuffle names\">\r\n          <ShuffleIcon size={14} />\r\n        </IconButton>\r\n        <IconButton onClick={() => {\r\n          if (isImportVisible && importMode === 'append') {\r\n            setIsImportVisible(false);\r\n          } else {\r\n            setImportMode('append');\r\n            setImportText('');\r\n            setIsImportVisible(true);\r\n          }\r\n        }} disabled={isLocked || names.length >= maxNames} title=\"Import names\" aria-label=\"Import names\">\r\n          <ImportIcon size={14} />\r\n        </IconButton>\r\n        <IconButton onClick={() => {\r\n          if (isImportVisible && importMode === 'replace') {\r\n            setIsImportVisible(false);\r\n          } else {\r\n            setImportMode('replace');\r\n            setImportText(names.join('\\n') + (names.length > 0 ? '\\n' : ''));\r\n            setIsImportVisible(true);\r\n          }\r\n        }} disabled={isLocked || names.length === 0} title=\"Bulk Edit\" aria-label=\"Bulk Edit names\">\r\n          <EditIcon size={14} />\r\n        </IconButton>\r\n        <IconButton onClick={handleClearAll} disabled={names.length === 0 || isLocked} title=\"Clear all\" aria-label=\"Clear all names\">\r\n          <ClearAllIcon size={14} />\r\n        </IconButton>\r\n        <IconButton onClick={() => setIsSaveModalVisible(true)} disabled={names.length === 0 || isLocked} title=\"Save list\" aria-label=\"Save list\">\r\n          <SaveIcon size={14} />\r\n        </IconButton>\r\n        <IconButton onClick={() => setIsLoadModalVisible(true)} disabled={savedLists.length === 0 || isLocked} title=\"Load list\" aria-label=\"Load saved list\">\r\n          <HistoryIcon size={14} />\r\n        </IconButton>\r\n      </ButtonRow>\r\n\r\n      <AnimatePresence>\r\n        {isImportVisible && (\r\n          <motion.div\r\n            initial={{ height: 0, opacity: 0 }}\r\n            animate={{ height: 'auto', opacity: 1 }}\r\n            exit={{ height: 0, opacity: 0 }}\r\n            style={{ overflow: 'hidden' }}\r\n          >\r\n            <div style={{ paddingTop: '4px', paddingBottom: '8px' }}>\r\n              <Label>{importMode === 'append' ? 'Paste names to append' : 'Edit current list'}</Label>\r\n              <TextArea\r\n                value={importText}\r\n                onChange={(event) => setImportText(event.target.value)}\r\n                placeholder={\"John\\nJane\\nBob\\n...\"}\r\n              />\r\n              <ButtonRow style={{ marginTop: 8 }}>\r\n                <FlexButton onClick={handleImport}>\r\n                  {importMode === 'append' ? 'Add Names' : 'Save Changes'}\r\n                </FlexButton>\r\n                <IconButton onClick={() => setIsImportVisible(false)} title=\"Close\" aria-label=\"Close edit panel\">\r\n                  <CloseIcon size={14} />\r\n                </IconButton>\r\n              </ButtonRow>\r\n            </div>\r\n          </motion.div>\r\n        )}\r\n      </AnimatePresence>\r\n\r\n      <div style={{ marginTop: '0' }}>\r\n        <Label>\r\n          {names.length} name{names.length !== 1 ? 's' : ''}\r\n          {maxNames !== Infinity ? ` / ${maxNames}` : ''}\r\n        </Label>\r\n        <NameListContainer role=\"list\" aria-label=\"Names list\">\r\n          {names.length === 0 ? (\r\n            <EmptyState>\r\n              No names yet!<br />\r\n              Add names above or click the import button to paste a list.\r\n            </EmptyState>\r\n          ) : (\r\n            <AnimatePresence initial={false}>\r\n              {names.map((name, index) => (\r\n                <NameItem\r\n                  key={`${name}-${index}`}\r\n                  initial={{ opacity: 0, height: 0 }}\r\n                  animate={{ opacity: 1, height: 'auto' }}\r\n                  exit={{ opacity: 0, height: 0 }}\r\n                  transition={{ duration: 0.15 }}\r\n                  role=\"listitem\"\r\n                >\r\n                  <div style={{ display: 'flex', alignItems: 'center', gap: '8px', overflow: 'hidden' }}>\r\n                    {showColors && <ColorDot $color={GAME_COLORS[index % GAME_COLORS.length]} />}\r\n                    <span style={{ overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>\r\n                      {name}\r\n                    </span>\r\n                  </div>\r\n                  <RemoveBtn onClick={() => handleRemove(index)} title=\"Remove\" aria-label={`Remove ${name}`} disabled={isLocked}>\r\n                    <CloseIcon size={12} />\r\n                  </RemoveBtn>\r\n                </NameItem>\r\n              ))}\r\n            </AnimatePresence>\r\n          )}\r\n        </NameListContainer>\r\n      </div>\r\n\r\n      {/* Save Modal */}\r\n      {isSaveModalVisible && (\r\n        <SaveModal\r\n          listName={listName}\r\n          onListNameChange={setListName}\r\n          onSave={handleSaveList}\r\n          onClose={() => setIsSaveModalVisible(false)}\r\n        />\r\n      )}\r\n\r\n      {/* Load Modal */}\r\n      {isLoadModalVisible && (\r\n        <LoadModal\r\n          savedLists={savedLists}\r\n          onLoad={handleLoadList}\r\n          onDelete={handleDeleteList}\r\n          onClose={() => setIsLoadModalVisible(false)}\r\n        />\r\n      )}\r\n    </ControlsPanel>\r\n  );\r\n};\r\n\r\nexport default SharedNameControls;\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\admin\\Documents\\Web Projects\\chooz-app\\src\\components\\common\\SharedNameControls.styles.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\admin\\Documents\\Web Projects\\chooz-app\\src\\hooks\\useLocalStorage.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\admin\\Documents\\Web Projects\\chooz-app\\src\\main.jsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\admin\\Documents\\Web Projects\\chooz-app\\src\\utils\\colors.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\admin\\Documents\\Web Projects\\chooz-app\\src\\utils\\sounds.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\admin\\Documents\\Web Projects\\chooz-app\\vite.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]
